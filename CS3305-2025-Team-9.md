# LET ME COOK 
https://github.com/BadWolf02/LetMeCook

## 1. Overview & Purpose

### 1.1 The Problem

### 1.2 The Solution, Our App

## 2. Architecture

### 2.1 High Level View
![team9_letmecook-architecture.jpg](report-imgs%2Fteam9_letmecook-architecture.jpg)
Figure 2.1: LetMeCook Architecture

#### 2.1.1 Firebase Firestore
Firebase Firestore (Firestore) is a **NoSQL document-based** database. It allows apps to store and sync data in 
real time **asynchronously**. It offered the following additional benefits:
- Offline support. Data can be accessed and modified offline and synced when online.
- Google's security guarantees.
- Large number of reads and writes for free

We used Firestore to store the majority of our data, except for sensitive user data and images. 
We used Firestore to store the following collections and fields:
- Households
  - Household name
  - Inventory
  - Invited users
  - Members
  - Shopping list
- Ingredients
  - Name
  - ID
  - Allergens
  - Calories
  - Category
  - Serving size
- Recipes
  - Name
  - Author
  - Cuisine
  - Type
  - Allergens
  - Ingredients
  - Steps
  - Average rating
  - Reviews
- Users
  - Email
  - Username
  - Household Document ID
  - Invites
  - Favourite Recipes

#### 2.1.2 Firebase Authentication
Firebase Authentication is a service that provides secure user authentication for apps. It supports multiple 
authentication methods and simplifies user management, handles **session persistence**, and integrates with 
Firebase Firestore for user-based data security. It allows easy implementation of **password restrictions** 
and allows disabling/deleting accounts from a console.

In our case we used **email authentication and verification**. Our users could remain logged in after refreshing 
the app or closing their phone. We stored the generated user ID from Authentication in Firestore as a 
user's document ID to verify user details.


#### 2.1.3 Firebase Storage
Firebase Storage is a cloud service used for storing and fetching **user-generated files**, such as images, 
videos, and documents. It allows:
- Scalable storage with Google Cloud infrastructure
- Secure file access using Firebase Authentication and Firestore Security Rules
- Efficient uploads & downloads with automatic handling of network interruptions
- Direct URL sharing for accessing stored files

We used Firebase Storage to store images for recipes, which are uploaded when a user creates 
a recipe or scrapes one from the web.

#### 2.1.4 ML Kit

#### 2.1.5 OpenFoodFacts

#### 2.1.6 BBC Good Foods

### 2.2 Android Architecture

#### 2.2.1 Activities and Fragments
An **Activity** is a single, focused thing in an app. Data persists while the activity is running.
A **Fragment** is a component that lives inside an Activity and depends on its lifecycle.

We used Fragments for our primary 5 pages, navigated to via the navigation bar. These pages run 
on the **MainActivity**. This ensured smooth navigation and that the main interactable pages would have 
their data remain loaded. We used Activities to open smaller pages with a **shorter lifecycle**. 

#### 2.2.2 Model-View-ViewModel (MVVM) Architecture
![team9_mvvm.png](report-imgs%2Fteam9_mvvm.png)
Figure 2.2: MVVM Architecture

MVVM is a software design pattern commonly used in Android development to separate concerns and improve 
code organization. Its components include:
- **Model**: Represents the data layer
- **View**: Represents the UI layer
- **ViewModel**: Acts as a bridge between the two layers.

We constantly aimed to adhere to this architecture, but found fragments to be difficult to work with so we
deviated in strictly using the ViewModel in some fragments.

// add architecture overview, look up names of different architectures

### 2.3 Dependencies & Other Resources

#### 2.3.1 Glide
Glide is an open-source image loading library for Android. It can load images from Firebase Storage 
and efficiently caches images on retrieval.

#### 2.3.2 Google Fonts
Google provides a large variety of standardised images, symbols and logos for Android in XML format for download. 
We made use of a wide variety of these throughout our app.


### use case diagram??
### architecutre of Activity and intents, drawn with eg. text underneath describing it as well as mentioning which of our other java classes use this
### Explanation of data model, mention single source of truth if we use it + control based access if I still manage to implement the authorname and the 

## 3. Main Components

### 3.1 Sign Up
![team9_signup.jpg](report-imgs%2Fteam9_signup.jpg)
Figure 3.1: Sign Up page screenshot

### 3.1.1 Account Creation

### 3.1.2 Verification
![team9_verification.jpg](report-imgs%2Fteam9_verification.jpg)
Figure 3.2: Verification email screenshot

### 3.2 Login
![team9_login.jpg](report-imgs%2Fteam9_signup.jpg)
Figure 3.3: Login page screenshot

### 3.3 Home Page
![team9_homepage.jpg](report-imgs%2Fteam9_homepage.jpg)
Figure 3.4: Home page screenshot

#### 3.3.1 Recipe Filtering

#### 3.3.2 Recipe List

#### 3.3.3 What Can I Cook?

### 3.4 Recipe View
![team9_recipeview.jpg](report-imgs%2Fteam9_recipeview.jpg)
Figure 3.5: Recipe View page screenshot. Details, favourite, add to shopping list
![team9_recipeview2.jpg](report-imgs%2Fteam9_recipeview2.jpg)
Figure 3.6: Continuation of Recipe View page. Reviews.

#### 3.4.1 Recipe Details

#### 3.4.2 Favourite Button

#### 3.4.3 Add to Shopping List Button

#### 3.4.4 Reviews

### 3.5 Chef's Corner (Recipe Creation)

![team9_chefscorner.jpg](report-imgs%2Fteam9_chefscorner.jpg)
Figure 3.7: Chef's Corner page screenshot. Name, meal type, ingredients, steps, cuisine, time spent cooking.
![team9_chefscorner2.jpg](report-imgs%2Fteam9_chefscorner2.jpg)
Figure 3.8: Continuation of Chef's Corner page. Cuisine, time spent cooking, time spent prepping, 
add recipe, select image, scraping.

### 3.6 Inventory Page
![team9_inventory.jpg](report-imgs%2Fteam9_inventory.jpg)
Figure 3.9: Inventory page screenshot.

#### 3.6.1 Ingredient List
![team9_ingredient-db-item.png](report-imgs%2Fteam9_ingredient-db-item.png)
Figure 3.10: Sample ingredient in Firestore database.

#### 3.6.2 Barcode Scanning
![team9_scanner.jpg](report-imgs%2Fteam9_scanner.jpg)
Figure 3.11: Barcode scanning a pringles can.

### 3.7 Shopping Page
![team9_shoppinglist.jpg](report-imgs%2Fteam9_shoppinglist.jpg)
Figure 3.12: Shopping page screenshot

### 3.8 User Page
![team9_userpage.jpg](report-imgs%2Fteam9_userpage.jpg)
Figure 3.13: User page screenshot

#### 3.8.1 User Details

#### 3.8.2 Edit Profile
![team9_edit-profile.jpg](report-imgs%2Fteam9_edit-profile.jpg)
Figure 3.14: Edit Profile page screenshot

#### 3.8.3 Sign Out

### 3.9 Manage Household Page
![team9_managehousehold.jpg](report-imgs%2Fteam9_managehousehold.jpg)
Figure 3.15: Manage Household page screenshot

### 3.10 View Invites page
![team9_invites.jpg](report-imgs%2Fteam9_invites.jpg)
Figure 3.16: View Invites page screenshot

### 3.11 Favourite Recipes
![team9_favourites.jpg](report-imgs%2Fteam9_favourites.jpg)
Figure 3.17: Favourite Recipes page screenshot


## 4 Challanges &  Lessons learned
We experienced a wide variety of challenges, largely caused by interacting with new technologies. We have 
been lucky to be able to work with Java, a language that we are familiar with through our coursework, 
however this came with its own challenges. The Android development community no longer focuses its 
efforts on Java, but rather Kotlin.

### 4.1 Dependency clashes
**Morgan**

### 4.2 Poor Firebase documentation
We found the documentation for Firebase to be incredibly poor, lacking any mention of methods that are 
used in Firebase Firestore, Firebase Authentication or Firebase Storage. We found some useful functions 
in an **open-source GitHub repo** that showcased the various uses of Firebase. We additionally had 
to read various **Firebase blogs**, written by the community, to find reference to different 
functionalities, such as callbacks.

### 4.3 Asynchronous data retrieval
One of the largest issues was creating database searching methods to be reused in our activities. 
This was done for separation of concerns but we later realised how essential it was since 
Firebase Firestore queries are asynchronous.

We had to create listener functions, using a **callback-based approach**. New listeners were created for 
different data types and use them to return the relevant data for use in other methods. 
This resulted in code being written using **lambda functions** for our callback, which was new for us.

### 4.4 Android Studio corrupting Gradle builds
...

## 5 Contribution of Team members

### 5.1 Joseph 122320603

### 5.2 Nutsa

### 5.3 Jack

### 5.4 Morgan

### 5.5 Megan